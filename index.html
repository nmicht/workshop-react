<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>ReactJS 101</title>

  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <link rel="stylesheet" href="reveal.js/css/theme/simple.css">
  <link rel="stylesheet" href="assets/css/font-awesome.min.css">
  <link rel="stylesheet" href="assets/css/custom.css">


  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

  <!-- Printing and PDF exports -->
  <script>
  var link = document.createElement( 'link' );
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
  document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- Presentation -->
      <section>
        <h2>Primeros Pasos</h2>
        <h1>ReactJS 101</h1>
      </section>

      <section>
        <h3>¿Por qué ReactJS?</h3>
        <ul>
          <li>Angular VS React</li>
          <li>¿Esta de moda?</li>
          <li>Metodología de componentes</li>
        </ul>
      </section>

      <section>
        <h3>Michelle Torres</h3>
        Lead Software Engineer at TiempoDevelopment • Professor at UdG •
        Founder & CTO at @CORBmx • Speaker • Free software advocate • Crazy
        <ul style="list-style-type: none">
          <li><i class="fa fa-envelope" aria-hidden="true"></i> michelle.torres@corb.mx</li>
          <li><i class="fa fa-facebook-square" aria-hidden="true"></i> fb.com/michelletorres.mx</li>
          <li><i class="fa fa-twitter-square" aria-hidden="true"></i> nmicht</li>
          <li><i class="fa fa-github-square" aria-hidden="true"></i> nmicht</li>
        </ul>
      </section>

      <section>
        Vamos a trabajar este taller haciendo un <strong>Pomodorito</strong>
        <a href="https://github.com/nmicht/pomodorito">https://github.com/nmicht/pomodorito</a>
      </section>

      <section>
        <h3>Instalar NPM</h3>
        Para iniciar, tenemos que instalar NPM.
        NPM (node package manager) es el gestor de paquetes javascript de
        NODE.JS, y te recomiendo instalarlo usando.
        <a href="https://github.com/creationix/nvm/blob/master/README.md">NVM</a>
        NVM es el Gestor de Versiones de Node.
      </section>

      <section>
        <h3>Instalación</h3>
        Instalar <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>
        <pre><code data-trim>npm install -g create-react-app</code></pre>
        <p class="tip"><strong>-g</strong> lo utilizamos para indicar que será una
        instalación global.</p>
      </section>

      <section>
        <h3>Crea tu primer App</h3>
        <ol>
          <li>
            Crear tu app
            <pre><code data-trim>create-react-app pomodorito</code></pre>
          </li>
          <li>
            Arrancar el servidor de pruebas <strong>en una consolado por aparte</strong>
            <pre><code data-trim>
cd pomodorito/
npm start
          </code></pre>
          </li>
          Para arrancar el servidor, puedes usar también
          <pre><code data-trim>yarn start</code></pre>
        </ol>
      </section>

      <section>
        <h3>Estructura de tu App</h3>
        Todo tu código fuente incluídos assets va en <strong>src</strong>, es la
        que se compila.<br>
        <strong>public</strong> tiene todo lo público al servidor web estático.<br>
        <img src="assets/img/folder.png" alt="">
      </section>

      <section>
        Entendiendo el archivo App.js
      </section>

      <section>
        Manos a la obra
      </section>

      <section>
        <h3>Componente del contador</h3>
        <ol>
          <li>
            Crear carpeta de componentes
            <pre><code data-trim>
cd src
mkdir components
            </code></pre>
          </li>
          <li>
            Crear carpeta para el componente de contador
            <pre><code data-trim>
cd components
mkdir Counter
            </code></pre>
          </li>
        </ol>
        <p class="tip">Nuestro componente por estándar se define en CamelCase.</p>
      </section>

      <section>
        <ol>
          <li value="3">
            Crear archivo del componente como tal
            <pre><code data-trim>
cd Counter
touch Counter.js
            </code></pre>
          </li>
          <li>
            Crear archivo para manejar la carpeta como módulo
            <pre><code data-trim>touch index.js</code></pre>
          </li>
        </ol>
        <p class="tip">ReactJS cuando hace un import de un folder, busca un index.js</p>
      </section>

      <section>
        En el archivo Counter.js vamos a crear un componente representacional.
        También se le conoce como <strong>stateless component</strong>.
        Este componente será el contador de nuestro pomodorito.
        <pre><code data-trim>
import React from 'react';

const Counter = () => {
   return (
     <span>00:00</span>
   );
}

export default Counter;
        </code></pre>
      </section>

      <section>
        Ahora a nuestro index.js le diremos que utilice nuestro componente Counter
        <pre><code data-trim>
import Counter from './Counter';
export default Counter;
        </code></pre>
      </section>

      <section>
        Rendereamos nuestro componente Counter
        <ol>
          <li>
            Importamos nuestro counter
            <pre><code data-trim>import Counter from './components/Counter';</code></pre>
          </li>
          <li>
            En el render agregamos el componente
            <pre><code data-trim><Counter /></code></pre>
          </li>
        </ol>
        <pre><code data-trim>
import Counter from './components/Counter';
...
render() {
    return (
      <div className="App">
        ...
        <Counter />
      </div>
    );
  }
...
        </code></pre>
      </section>

      <section>
        <h3>Props</h3>
        <ol>
          <li>
            Son las propiedades de los componentes. Estos se le pasan al
            componente desde el componente padre.
          </li>
          <li>
            En el renderizado del componente se definen como si fueran atributos de
            html.
            <pre><code data-trim><Counter minutes={10} seconds={15} /></code></pre>
          </li>
          <li>
            En la declaración del componente se usan a través del objeto
            <strong>props</strong>.
            <pre><code data-trim>
const Counter = (props) => {
   return (
     <span>{props.minutes}:{props.seconds}</span>
   );
}
            </code></pre>
          </li>
        </ol>
      </section>

      <section>
        <h3>PropTypes</h3>
        <a href="https://reactjs.org/docs/typechecking-with-proptypes.html">PropTypes</a>
        es la definición de las propiedades que tendrá tu componente, para
        hacer claro/documentable tu código.<br>
        Antes eran parte de React, pero ahora es decisión del developer, por lo
        cual tienes que instalarlo como una dependencia.
        <pre><code>npm install prop-types --save</code></pre>
      </section>

      <section>
        Importamos el módulo
        <pre><code>import PropTypes from 'prop-types';</code></pre>
        Describimos nuestros props
        <pre><code data-trim>
Counter.propTypes = {
  time: PropTypes.number.isRequired,
}
        </code></pre>
      </section>
      <section>
        <h3>Destructurización</h3>
        Para simplificar el uso de los props usamos la destructurización, que
        extrae los valores del objeto.
        <pre><code data-trim>
const Counter = ({minutes, seconds}) => {
   return (
     <span>{minutes}:{seconds}</span>
   );
}
        </code></pre>
      </section>

      <section>
        <h3>Componente de acciones Pomodoro</h3>
        Crear carpeta para el componente de contador
        <pre><code data-trim>
cd components
mkdir Pomodoro
        </code></pre>
      </ol>
      <p class="tip">Nuestro componente por estándar se define en CamelCase.</p>
    </section>

    <section>
      <ol>
        <li value="3">
          Crear archivo del componente como tal
          <pre><code data-trim>
cd Pomodoro
touch Pomodoro.js
          </code></pre>
        </li>
        <li>
          Crear archivo para manejar la carpeta como módulo
          <pre><code data-trim>touch index.js</code></pre>
        </li>
      </ol>
      <p class="tip">ReactJS cuando hace un import de un folder, busca un index.js</p>
    </section>

    <section>
      En el archivo Pomodoro.js vamos a renderear todo nuestro Pomodorito
      <pre><code data-trim>
import React from 'react';
import Pomodoro from '../Pomodoro';

const Pomodoro = () => {
   return (
     <div>
         <Counter minutes={10} seconds={15} />
         { /*...botones...*/ }
     </div>
   );
}

export default Pomodoro;
      </code></pre>
    </section>

    <section>
      Ahora a nuestro index.js le diremos que utilice nuestro componente Pomodoro
      <pre><code data-trim>
import Pomodoro from './Pomodoro';
export default Pomodoro;
      </code></pre>
    </section>

    <section>
      Modificamos nuestro archivo App.js para renderizar el Pomodoro y ya no
      el Counter.
      <pre><code data-trim>
import React, { Component } from 'react';
import Pomodoro from './components/Pomodoro';
...

class App extends Component {
  render() {
    return (
        ...
        <Pomodoro />
        ...
    );
  }
}

export default App;
      </code></pre>
    </section>

    <section>
      <h3>La biblioteca moment.js</h3>
      <a href="https://momentjs.com/">moment</a> se usa para manejo de fechas en
      JS.
      <ol>
        <li>Dentro del folder de Pomodorito instalamos la biblioteca</li>
        <pre><code>npm install moment --save</code></pre>
      </ol>
      <p class="tip"><strong>--save</strong> es para que se guarde como dependencia en nuestro proyecto.</p>
    </section>

    <section>
      <h3>Agregamos moment al Counter</h3>
      <pre><code data-trim>
import React from 'react';
import moment from 'moment';

const Counter = ({time}) => {
   return (
     <span>{moment(time).format('mm:ss')}</span>
   );
}

export default Counter;
      </code></pre>
    </section>

    <section>
      Indicamos al counter la cantidad de tiempo
      que queremos mostrar.
      Este cambio se hace en los props.
      <pre><code><Counter time={15000} /></code></pre>
      El tiempo es en milisegundos.
    </section>

    <section>
      <h3>State Component</h3>
      Convertimos nuestro componente stateless
      Pomodoro a un componente con estado.
      <pre><code data-trim>
import React from 'react';
import Counter from '../Counter';

class Pomodoro extends React.Component {
  render() {
    return (
      <div>
          <Counter time={15000} />
          { /*botones*/ }
      </div>
    );
  }
}

export default Pomodoro;
      </code></pre>
    </section>

    <section>
      <h3>Constructor de un componente</h3>
      <pre><code data-trim>
constructor(props) {
    super(props);

    this.state = {
      intervalId: null, //ID for the interval to update the time
      breaksCount: 0, //Count for each "time break"
      currentBreak: 'pomodoro', //Type of current "time break"
    }
}
      </code></pre>
    </section>

    <section>
      Método para crear un "tiempo"
      <pre><code data-trim>
setDuration(minutes) {
  return moment.duration(minutes * 60, 'seconds');
}
      </code></pre>
      La agregamos en nuestra clase Pomodoro.
      <p class="tip">No olvides importar el módulo de moment.</p>
    </section>

    <section>
      <h3>Definimos las propiedades del Pomodoro.</h3>
      Esto en nuestra App.js que lo renderiza, le definimos los minutos para el
      timer, para el descanso corto y para el descanso largo.
      <pre><code data-trim>
<Pomodoro
     pomodoro={2}
     shortBreak={1}
     longBreak={3}
/>
      </code></pre>
    </section>

    <section>
      Usando los props, agregamos al estado de nuestro componente el valor para
      mantener la duración del timer.
      <pre><code>currentDuration: this.setDuration(props.pomodoro),</code></pre>
    </section>

    <section>
      <h3>¿Y los botones?</h3>
      Ahora, ya que tenemos el timer necesitamos un botón que lo active.
      <pre><code data-trim>
<div>
  <button>
    Start
  </button>
  <button>
    Reset
  </button>
</div>
      </code></pre>
    </section>

    <section>
      <h3>Hagamos que inicie el counter</h3>
      A nuestro botón, le ponemos el evento
      <pre><code>onClick={this.handleStartClick}</code></pre>
      Y en nuestra clase agregamos el método
      <pre><code data-trim>
handleStartClick = () => {
   const intervalId = setInterval( () => {
     console.log('corriendo intervalo');
   }, 1000);
   this.setState({ intervalId });
}
      </code></pre>
    </section>

    <section>
      <h3>Timer</h3>
      <pre><code data-trim>
timer = () => {
  this.setState((state) => {
      const seconds = state.currentDuration.asSeconds();
      if (seconds <= 1) {
          clearInterval(state.intervalId);
          // Debemos cambiar al nuevo break y aumentar el contador de breaks
      }
      return {
        currentDuration: moment.duration(seconds - 1, 'seconds')
      };
  });
}
      </code></pre>
      <p class="tip">Cuando retornas en la función setState el objeto se va a mergear
        con el state actual.</p>
    </section>

    <section>
      Al counter le mandamos el currentDuration para hacerlo dinamico
      <pre><code><Counter time={this.state.currentDuration.asMilliseconds()} /></code></pre>
    </section>

    <section>
      Modificamos el handle del click para ejecutar nuestro timer
      <pre><code data-trim>
handleStartClick = () => {
   const intervalId = setInterval( this.timer, 1000);
   this.setState({ intervalId });
}
      </code></pre>
    </section>

    <section>
      <h3>Cambiar de break cuando termina el timer</h3>
      Después de que nuestro contador llega a 0, necesitamos cambiar al siguiente
      "break"/bloque.
      <pre><code>
getNextTime = () => {
  if (this.state.currentBreak === 'pomodoro') {
      if (this.state.breaksCount === MAX_BREAKS) {
        return 'longBreak';
      }

      return 'shortBreak';
  }

  return 'pomodoro';
}
      </code></pre>
    </section>

    <section>
      <h3>Cambiar de break cuando termina el timer</h3>
      La lógica para cambiar de break debería estar dentro de un método para
      cada que finaliza el timer.
      <pre><code data-trim>
finishTime = () => {
  let breaksCount = this.state.breaksCount;

  if (this.state.currentBreak === 'shortBreak') {
    breaksCount += 1;
  } else if (breaksCount === MAX_BREAKS) {
    breaksCount = 0;
  }

  const nextTime = this.getNextTime();

  return {
      currentBreak: nextTime,
      currentDuration: this.setDuration(this.props[nextTime]),
      breaksCount,
  };
}
      </code></pre>
    </section>

    <section>
      Ahora nuestro timer deberá ejecutar el finishTime
      <pre><code>return this.finishTime();</code></pre>
    </section>

    <section>
      <h3>Push Notifications</h3>
      Para hacer que nuestro browser arroje notificaciones al terminar un break
      instalaremos <a href="https://pushjs.org/">push.js</a>.
      <pre><code>npm install push.js --save</code></pre>
    </section>

    <section>
      Creamos un método para manejar las notificaciones dentro de nuestro App.js
      <pre><code data-trim>
handleTimerFinish = (finishedTime) => {
  Push.create(`Terminó tu ${finishedTime}`, {
    body: 'Da click aquí para ir al Pomodorito',
    icon: 'icon.png',
    timeout: 4000,
    onClick: function() {
      window.focus();
      this.close();
    }
  });
}
      </code></pre>
    </section>

    <section>
      Mandamos como props al Pomodoro el callback
      <pre><code data-trim>
<Pomodoro
     pomodoro={2}
     shortBreak={1}
     longBreak={3}
     onTimerFinish={this.handleTimerFinish}
/>
      </code></pre>
      y no olvides agregarlo a tus PropTypes
      <pre><code>onTimerFinish: PropTypes.func,</code></pre>
    </section>

    <section>
      Cuando se termine nuestro tiempo, queremos ejecutar un callback que se
      encargue de lanzar la notificación.<br>
      Entonces agregaremos en el método finishTime la llamada.
      <pre><code>this.props.onTimerFinish(this.state.currentBreak);</code></pre>
    </section>

    <section>
      Ahora hagamos que se vea bonito
    </section>

    <section>
      Existen muchos paquetes para dar estilo, sin embargo, para terminar el
      workshop implementaremos CSS de la manera sencilla y rápida.
    </section>

    <section>
      Creamos un objeto de styles
      <pre><code data-trim>
const styles = {
  fontSize: "42px",
  backgroundColor: "rgb(225, 225, 225)",
  padding: "35px",
  display: "inline-block",
  margin: "40px",
}
      </code></pre>
    </section>

    <section>
      Asignamos el style a través de CSS inline
      <pre><code><span style={styles}>{moment(time).format('mm:ss')}</span></code></pre>
    </section>

    <section>
      GRACIAS
    </section>

    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>
  // More info about config & dependencies:
  // - https://github.com/hakimel/reveal.js#configuration
  // - https://github.com/hakimel/reveal.js#dependencies
  Reveal.initialize({
    slideNumber: true,
    dependencies: [
      { src: 'reveal.js/plugin/markdown/marked.js' },
      { src: 'reveal.js/plugin/markdown/markdown.js' },
      { src: 'reveal.js/plugin/notes/notes.js', async: true },
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
    ]
  });
  </script>
</body>
</html>
